/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Component,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  Component = (function() {
    module.exports = Component;

    Component.prototype.name = "Component";

    Component.prototype.gameObject = null;

    function Component(name) {
      this.name = name;
      this.receive = bind(this.receive, this);
      this.gameObject = null;
    }

    Component.prototype.receive = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    };

    return Component;

  })();

}).call(this);

//# sourceMappingURL=Component.js.map


/***/ }),
/* 1 */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Game,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Game = (function() {
    function Game() {
      this._onWindowResize = bind(this._onWindowResize, this);
      this._loop = bind(this._loop, this);
      this._initialize = bind(this._initialize, this);
      this.setScene = bind(this.setScene, this);
      this.start = bind(this.start, this);
    }

    module.exports = Game;

    Game.prototype.scene = null;

    Game.prototype.start = function() {
      this.nowTime = this.prevTime = Date.now();
      this._initialize();
      return this._loop();
    };

    Game.prototype.setScene = function(scene) {
      this.scene = scene;
      Game.scene = this.scene;
      return this;
    };

    Game.prototype._initialize = function() {
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(this.renderer.domElement);
      return window.addEventListener('resize', this._onWindowResize, false);
    };

    Game.prototype._loop = function() {
      var deltaTime, ref, ref1;
      this.nowTime = Date.now();
      deltaTime = this.nowTime - this.prevTime;
      if ((ref = this.scene) != null) {
        ref.update(deltaTime);
      }
      if (((ref1 = this.scene) != null ? ref1._cameras[0] : void 0) != null) {
        this.renderer.render(this.scene._scene, this.scene._cameras[0]);
      }
      requestAnimationFrame(this._loop);
      return this.prevTime = this.nowTime;
    };

    Game.prototype._onWindowResize = function() {
      var ref, ref1, ref2, ref3;
      if ((ref = this.scene) != null) {
        if ((ref1 = ref._cameras[0]) != null) {
          ref1.aspect = window.innerWidth / window.innerHeight;
        }
      }
      if ((ref2 = this.scene) != null) {
        if ((ref3 = ref2._cameras[0]) != null) {
          ref3.updateProjectionMatrix();
        }
      }
      return this.renderer.setSize(window.innerWidth, window.innerHeight);
    };

    Game.requestPointerLock = function() {
      document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;
      return document.body.requestPointerLock();
    };

    Game.requestFullScreen = function() {
      document.documentElement.requestFullscreen = document.documentElement.requestFullscreen || document.documentElement.mozRequestFullScreen || document.documentElement.webkitRequestFullScreen || document.documentElement.msRequestFullscreen;
      document.documentElement.requestFullscreen();
      return Game.requestPointerLock();
    };

    Game.exitFullScreen = function() {
      document.exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitCancelFullScreen || document.msExitFullscreen;
      return document.exitFullscreen();
    };

    Game.isFullScreen = function() {
      return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement;
    };

    return Game;

  })();

}).call(this);

//# sourceMappingURL=Game.js.map


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Game, GameObject,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  Game = __webpack_require__(1);

  GameObject = (function() {
    module.exports = GameObject;

    GameObject.prototype.isGameObject = true;

    GameObject.prototype.mesh = null;

    GameObject.prototype.components = {};

    GameObject.property('mesh', {
      get: function() {
        return this._mesh;
      },
      set: function(mesh) {
        var ref, ref1;
        if (this._mesh != null) {
          this._mesh.gameObject = null;
          if ((ref = Game.scene) != null) {
            ref._scene.remove(this._mesh);
          }
        }
        this._mesh = mesh;
        if (mesh != null) {
          mesh.gameObject = this;
          return (ref1 = Game.scene) != null ? ref1._scene.add(mesh) : void 0;
        }
      }
    });

    function GameObject(mesh1) {
      this.mesh = mesh1;
      this.broadcast = bind(this.broadcast, this);
      this.removeComponent = bind(this.removeComponent, this);
      this.getComponent = bind(this.getComponent, this);
      this.addComponent = bind(this.addComponent, this);
      this.components = {};
      this.isGameObject = true;
    }

    GameObject.prototype.addComponent = function(comp) {
      comp.gameObject = this;
      this.components[comp.name] = comp;
      return typeof comp.afterAdded === "function" ? comp.afterAdded() : void 0;
    };

    GameObject.prototype.getComponent = function(name) {
      return this.components[name];
    };

    GameObject.prototype.removeComponent = function(name) {
      var comp;
      comp = this.components[name];
      if (comp == null) {
        return;
      }
      if (typeof comp.beforeRemoved === "function") {
        comp.beforeRemoved();
      }
      comp.gameObject = null;
      return this.components[name] = null;
    };

    GameObject.prototype.broadcast = function() {
      var args, comp, name, ref, results;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ref = this.components;
      results = [];
      for (name in ref) {
        comp = ref[name];
        results.push(comp.receive.apply(comp, args));
      }
      return results;
    };

    return GameObject;

  })();

}).call(this);

//# sourceMappingURL=GameObject.js.map


/***/ }),
/* 3 */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Scene,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Scene = (function() {
    module.exports = Scene;

    function Scene(initializer) {
      this.update = bind(this.update, this);
      this._removeGameObject = bind(this._removeGameObject, this);
      this.remove = bind(this.remove, this);
      this.add = bind(this.add, this);
      this._scene = new Physijs.Scene();
      this._cameras = [];
      this._objects = [];
      initializer(this);
    }

    Scene.prototype.add = function(object) {
      if (object.isGameObject) {
        this._objects.push(object);
        this._scene.add(object.mesh);
        if (object.getComponent("Camera") != null) {
          return this._cameras.push(object.getComponent("Camera")._camera);
        }
      } else {
        return this._scene.add(object);
      }
    };

    Scene.prototype.remove = function(object) {
      if (object.isGameObject) {
        return this._removeGameObject(object);
      }
      if (object.isMesh) {
        return this._removeGameObject(object.gameObject);
      }
      return this._scene.remove(object);
    };

    Scene.prototype._removeGameObject = function(object) {
      if (object == null) {
        return;
      }
      if (object.getComponent("Camera") != null) {
        this._cameras.remove(object.getComponent("Camera")._camera);
      }
      if (object.mesh != null) {
        this._scene.remove(object.mesh);
      }
      return this._objects.remove(object);
    };

    Scene.prototype.update = function(deltaTime) {
      var comp, i, len, name, object, ref, ref1;
      ref = this._objects;
      for (i = 0, len = ref.length; i < len; i++) {
        object = ref[i];
        ref1 = object != null ? object.components : void 0;
        for (name in ref1) {
          comp = ref1[name];
          if (typeof comp.update === "function") {
            comp.update(deltaTime);
          }
        }
      }
      return this._scene.simulate();
    };

    return Scene;

  })();

}).call(this);

//# sourceMappingURL=Scene.js.map


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Camera, Component,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component = __webpack_require__(0);

  Camera = (function(superClass) {
    extend(Camera, superClass);

    module.exports = Camera;

    Camera.prototype.position = null;

    Camera.property('position', {
      get: function() {
        return this._camera.position;
      },
      set: function(position) {
        return this._camera.position = position;
      }
    });

    function Camera() {
      this.beforeRemoved = bind(this.beforeRemoved, this);
      this.afterAdded = bind(this.afterAdded, this);
      Camera.__super__.constructor.call(this, "Camera");
      this._camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 10000);
    }

    Camera.prototype.afterAdded = function() {
      return this.gameObject.mesh.add(this._camera);
    };

    Camera.prototype.beforeRemoved = function() {
      return this.gameObject.mesh.remove(this._camera);
    };

    return Camera;

  })(Component);

}).call(this);

//# sourceMappingURL=Camera.js.map


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Component, FirstPersonController, Input,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component = __webpack_require__(0);

  Input = __webpack_require__(9);

  FirstPersonController = (function(superClass) {
    var PI_2;

    extend(FirstPersonController, superClass);

    module.exports = FirstPersonController;

    PI_2 = Math.PI / 2;

    FirstPersonController.prototype.enabled = true;

    FirstPersonController.prototype.sensitivity = 1;

    FirstPersonController.prototype.move_velocity = 3;

    FirstPersonController.prototype.jump_velocity = 3;

    function FirstPersonController(camera, options) {
      var geometry, material, mesh;
      this.camera = camera;
      if (options == null) {
        options = {};
      }
      this.update = bind(this.update, this);
      this.beforeRemoved = bind(this.beforeRemoved, this);
      this.afterAdded = bind(this.afterAdded, this);
      this._onCollision = bind(this._onCollision, this);
      this._onMouseMove = bind(this._onMouseMove, this);
      FirstPersonController.__super__.constructor.call(this, "FirstPersonController");
      (this._pitch = new THREE.Object3D()).add(this.camera._camera);
      (this._yaw = new THREE.Object3D()).add(this._pitch);
      this._yaw2 = new THREE.Object3D();
      geometry = new THREE.BoxGeometry(0.08, 0.08, 0.5);
      material = new THREE.MeshBasicMaterial({
        color: 0xffcc99
      });
      mesh = new THREE.Mesh(geometry, material);
      this._pitch.add(mesh);
      mesh.position.set(0.25, 0, -0.2);
      this.enabled = true;
      this.sensitivity = options.sensitivity != null ? options.sensitivity : 1;
      this.move_velocity = options.move_velocity != null ? options.move_velocity : 3;
      this.jump_velocity = options.jump_velocity != null ? options.jump_velocity : 3;
      this._canJump = true;
    }

    FirstPersonController.prototype._onMouseMove = function(event) {
      var movementX, movementY;
      if (!this.enabled) {
        return;
      }
      movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
      movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
      this._yaw.rotation.y -= movementX * this.sensitivity / 1000;
      this._yaw2.rotation.y -= movementX * this.sensitivity / 1000;
      this._pitch.rotation.x -= movementY * this.sensitivity / 1000;
      return this._pitch.rotation.x = Math.max(-PI_2, Math.min(PI_2, this._pitch.rotation.x));
    };

    FirstPersonController.prototype._onCollision = function(other_object, linear_velocity, angular_velocity) {
      if (this.gameObject.mesh.position.y - other_object.position.y > 0) {
        return this._canJump = true;
      }
    };

    FirstPersonController.prototype.afterAdded = function() {
      this.gameObject.mesh.add(this._yaw);
      this.gameObject.mesh.add(this._yaw2);
      document.addEventListener('mousemove', this._onMouseMove, false);
      return this.gameObject.mesh.addEventListener('collision', this._onCollision);
    };

    FirstPersonController.prototype.beforeRemoved = function() {
      document.removeEventListener('mousemove', this._onMouseMove, false);
      return this.gameObject.mesh.removeEventListener('collision', this._onCollision);
    };

    FirstPersonController.prototype.update = function(deltaTime) {
      var distance, p;
      distance = this.move_velocity * deltaTime / 1000;
      if (Input.isPressed('D')) {
        this._yaw2.translateX(distance);
      }
      if (Input.isPressed('A')) {
        this._yaw2.translateX(-distance);
      }
      if (Input.isPressed('S')) {
        this._yaw2.translateZ(distance);
      }
      if (Input.isPressed('W')) {
        this._yaw2.translateZ(-distance);
      }
      p = this._yaw2.getWorldPosition();
      this.gameObject.mesh.position.x = p.x;
      this.gameObject.mesh.position.z = p.z;
      this._yaw2.position.set(0, 0, 0);
      this.gameObject.mesh.__dirtyPosition = true;
      if (this._canJump && Input.isPressed(32)) {
        this._canJump = false;
        this.gameObject.mesh.setLinearVelocity(new THREE.Vector3(0, this.jump_velocity, 0));
      }
      this.gameObject.mesh.rotation.set(0, 0, 0);
      return this.gameObject.mesh.__dirtyRotation = true;
    };

    return FirstPersonController;

  })(Component);

}).call(this);

//# sourceMappingURL=FirstPersonController.js.map


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Bullet, Component, FirstPersonShooter, Game, GameObject,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component = __webpack_require__(0);

  GameObject = __webpack_require__(2);

  Game = __webpack_require__(1);

  Bullet = __webpack_require__(10);

  FirstPersonShooter = (function(superClass) {
    extend(FirstPersonShooter, superClass);

    module.exports = FirstPersonShooter;

    FirstPersonShooter.prototype.cooldown = 1000;

    FirstPersonShooter.prototype.bullet_speed = 10;

    FirstPersonShooter.prototype.bullet_size = 0.05;

    FirstPersonShooter.prototype.bullet_color = 0xffff00;

    function FirstPersonShooter(_controller, options) {
      this._controller = _controller;
      if (options == null) {
        options = {};
      }
      this._makeBullet = bind(this._makeBullet, this);
      this._onFire = bind(this._onFire, this);
      this.beforeRemoved = bind(this.beforeRemoved, this);
      this.afterAdded = bind(this.afterAdded, this);
      FirstPersonShooter.__super__.constructor.call(this, "FirstPersonShooter");
      this._lastFireTime = 0;
      this.cooldown = options.cooldown != null ? options.cooldown : 1000;
      this.bullet_speed = options.bullet_speed != null ? options.bullet_speed : 10;
      this.bullet_size = options.bullet_size != null ? options.bullet_size : 0.05;
      this.bullet_color = options.bullet_color != null ? options.bullet_color : 0xffff00;
    }

    FirstPersonShooter.prototype.afterAdded = function() {
      return document.body.onclick = this._onFire;
    };

    FirstPersonShooter.prototype.beforeRemoved = function() {
      return document.body.onclick = null;
    };

    FirstPersonShooter.prototype._onFire = function() {
      var bullet, currentTime, rot_x, rot_y;
      currentTime = new Date();
      if (currentTime - this._lastFireTime < this.cooldown) {
        return;
      }
      this._lastFireTime = currentTime;
      Game.scene.add(bullet = this._makeBullet());
      rot_y = this._controller._yaw.rotation.y;
      rot_x = this._controller._pitch.rotation.x;
      return bullet.mesh.setLinearVelocity(new THREE.Vector3(-Math.sin(rot_y) * Math.cos(rot_x) * this.bullet_speed, Math.sin(rot_x) * this.bullet_speed, -Math.cos(rot_y) * Math.cos(rot_x) * this.bullet_speed));
    };

    FirstPersonShooter.prototype._makeBullet = function() {
      var geometry, material, mesh, obj, worldPosition;
      geometry = new THREE.SphereGeometry(this.bullet_size);
      material = new THREE.MeshBasicMaterial({
        color: this.bullet_color
      });
      mesh = new Physijs.SphereMesh(geometry, material);
      worldPosition = this.gameObject.mesh.position;
      mesh.position.set(worldPosition.x, worldPosition.y + 0.5, worldPosition.z);
      mesh.name = "bullet";
      obj = new GameObject(mesh);
      obj.addComponent(new Bullet());
      return obj;
    };

    return FirstPersonShooter;

  })(Component);

}).call(this);

//# sourceMappingURL=FirstPersonShooter.js.map


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Component, HUD,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component = __webpack_require__(0);

  HUD = (function(superClass) {
    extend(HUD, superClass);

    module.exports = HUD;

    function HUD() {
      this.update = bind(this.update, this);
      this.afterAdded = bind(this.afterAdded, this);
      HUD.__super__.constructor.call(this, "HUD");
    }

    HUD.prototype.afterAdded = function() {
      this._hud = document.createElement('div');
      this._hud.innerHTML = '当前玩家：CZP<br>击中数：0';
      this._hud.style.height = '100px';
      this._hud.style.width = '200px';
      this._hud.style.position = 'fixed';
      this._hud.style.backgroundColor = 'lightskyblue';
      return document.body.appendChild(this._hud);
    };

    HUD.prototype.update = function() {
      if (typeof PlayerInfo !== "undefined" && PlayerInfo !== null) {
        return this._hud.innerHTML = '当前玩家：CZP<br>击中数：' + PlayerInfo.hitCount;
      }
    };

    return HUD;

  })(Component);

}).call(this);

//# sourceMappingURL=HUD.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Component, Game, TreeCollider,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component = __webpack_require__(0);

  Game = __webpack_require__(1);

  TreeCollider = (function(superClass) {
    extend(TreeCollider, superClass);

    module.exports = TreeCollider;

    function TreeCollider() {
      this._onCollision = bind(this._onCollision, this);
      this.beforeRemoved = bind(this.beforeRemoved, this);
      this.afterAdded = bind(this.afterAdded, this);
      TreeCollider.__super__.constructor.call(this, "TreeCollider");
      window.PlayerInfo = window.PlayerInfo || {};
      if (PlayerInfo.hitCount == null) {
        PlayerInfo.hitCount = 0;
      }
    }

    TreeCollider.prototype.afterAdded = function() {
      return this.gameObject.mesh.addEventListener('collision', this._onCollision);
    };

    TreeCollider.prototype.beforeRemoved = function() {
      return this.gameObject.mesh.removeEventListener('collision', this._onCollision);
    };

    TreeCollider.prototype._onCollision = function(other_mesh, linear_velocity, angular_velocity) {
      if (other_mesh.name === "bullet") {
        Game.scene.remove(this.gameObject);
        return PlayerInfo.hitCount += 1;
      }
    };

    return TreeCollider;

  })(Component);

}).call(this);

//# sourceMappingURL=TreeCollider.js.map


/***/ }),
/* 9 */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Input;

  Input = (function() {
    function Input() {}

    module.exports = Input;

    Input._keyBitmap = [];

    Input._onKeyDown = function(event) {
      return Input._keyBitmap[event.keyCode] = true;
    };

    Input._onKeyUp = function(event) {
      return Input._keyBitmap[event.keyCode] = false;
    };

    Input.isPressed = function(arg) {
      var code;
      code = isNaN(arg) ? arg.toUpperCase().charCodeAt(0) : arg;
      return !!Input._keyBitmap[code];
    };

    document.addEventListener('keydown', Input._onKeyDown, false);

    document.addEventListener('keyup', Input._onKeyUp, false);

    return Input;

  })();

}).call(this);

//# sourceMappingURL=Input.js.map


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Bullet, Component, ExplodeAnimation, Game,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component = __webpack_require__(0);

  ExplodeAnimation = __webpack_require__(11);

  Game = __webpack_require__(1);

  Bullet = (function(superClass) {
    extend(Bullet, superClass);

    module.exports = Bullet;

    function Bullet() {
      this._onExplodeFinish = bind(this._onExplodeFinish, this);
      this._onCollision = bind(this._onCollision, this);
      this.beforeRemoved = bind(this.beforeRemoved, this);
      this.afterAdded = bind(this.afterAdded, this);
      Bullet.__super__.constructor.call(this, "Bullet");
    }

    Bullet.prototype.afterAdded = function() {
      return this.gameObject.mesh.addEventListener('collision', this._onCollision);
    };

    Bullet.prototype.beforeRemoved = function() {
      return this.gameObject.mesh.removeEventListener('collision', this._onCollision);
    };

    Bullet.prototype._onCollision = function(other_mesh, linear_velocity, angular_velocity) {
      this.gameObject.addComponent(new ExplodeAnimation(this._onExplodeFinish));
      this.gameObject.mesh.removeEventListener('collision', this._onCollision);
      return this.gameObject.mesh = null;
    };

    Bullet.prototype._onExplodeFinish = function() {
      return Game.scene.remove(this.gameObject);
    };

    return Bullet;

  })(Component);

}).call(this);

//# sourceMappingURL=Bullet.js.map


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
(function() {
  var Component, ExplodeAnimation, Game,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component = __webpack_require__(0);

  Game = __webpack_require__(1);

  ExplodeAnimation = (function(superClass) {
    extend(ExplodeAnimation, superClass);

    module.exports = ExplodeAnimation;

    ExplodeAnimation.prototype.count = 1000;

    ExplodeAnimation.prototype.speed = 0.01;

    ExplodeAnimation.prototype.size = 0.02;

    ExplodeAnimation.prototype.duration = 500;

    ExplodeAnimation.prototype.onExplodeFinish = null;

    function ExplodeAnimation(onExplodeFinish, options) {
      this.onExplodeFinish = onExplodeFinish;
      if (options == null) {
        options = {};
      }
      this._randomSpherePoint = bind(this._randomSpherePoint, this);
      this.update = bind(this.update, this);
      this.beforeRemoved = bind(this.beforeRemoved, this);
      this.afterAdded = bind(this.afterAdded, this);
      ExplodeAnimation.__super__.constructor.call(this, "ExplodeAnimation");
      this.count = options.count != null ? options.count : 1000;
      this.speed = options.speed != null ? options.speed : 0.01;
      this.size = options.size != null ? options.size : 0.02;
      this.duration = options.duration != null ? options.duration : 500;
      this._dirs = [];
    }

    ExplodeAnimation.prototype.afterAdded = function() {
      var geometry, i, j, material, p, ref;
      geometry = new THREE.Geometry();
      for (i = j = 0, ref = this.count; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        p = this.gameObject.mesh.position;
        geometry.vertices.push(new THREE.Vector3(p.x, p.y, p.z));
        this._dirs.push(this._randomSpherePoint());
      }
      material = new THREE.PointsMaterial({
        size: this.size,
        color: 0xffcc00
      });
      this._particles = new THREE.Points(geometry, material);
      this._startTime = new Date();
      return Game.scene.add(this._particles);
    };

    ExplodeAnimation.prototype.beforeRemoved = function() {
      return Game.scene.remove(this._particles);
    };

    ExplodeAnimation.prototype.update = function() {
      var i, j, particle, ref;
      for (i = j = ref = this.count; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
        particle = this._particles.geometry.vertices[i];
        particle.y += this._dirs[i].y;
        particle.x += this._dirs[i].x;
        particle.z += this._dirs[i].z;
      }
      this._particles.geometry.verticesNeedUpdate = true;
      if (new Date() - this._startTime > this.duration) {
        if (typeof this.onExplodeFinish === "function") {
          this.onExplodeFinish();
        }
        return Game.scene.remove(this._particles);
      }
    };

    ExplodeAnimation.prototype._randomSpherePoint = function() {
      var phi, theta, x, y, z;
      theta = Math.random() * Math.PI;
      phi = Math.random() * Math.PI * 2;
      x = Math.sin(theta) * Math.cos(phi) * this.speed * Math.random();
      y = Math.sin(theta) * Math.sin(phi) * this.speed * Math.random();
      z = Math.cos(theta) * this.speed * Math.random();
      return {
        x: x,
        y: y,
        z: z
      };
    };

    return ExplodeAnimation;

  })(Component);

}).call(this);

//# sourceMappingURL=ExplodeAnimation.js.map


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by maliut on 2017/4/21.
 */
var Game = __webpack_require__(1);
var Scene = __webpack_require__(3);
var GameObject = __webpack_require__(2);
var Camera = __webpack_require__(4);
var FirstPersonController = __webpack_require__(5);
var HUD = __webpack_require__(7);
var FirstPersonShooter = __webpack_require__(6);
var TreeCollider = __webpack_require__(8);
// 公用资源
var voxParser = new vox.Parser();
var meshes = {};
var gui = new dat.GUI();
// 加载模型资源
var MODEL_COUNT = 6;
voxParser.parse('vox/obj_tree1.vox').then(function (voxelData) {
    var threeMesh = (new vox.MeshBuilder(voxelData, {voxelSize: 0.025})).createMesh();
    meshes.tree = new Physijs.BoxMesh(threeMesh.geometry, threeMesh.material, 0);
    checkLoad();
});
voxParser.parse('vox/obj_wall.vox').then(function (voxelData) {
    var threeMesh = (new vox.MeshBuilder(voxelData, {voxelSize: 0.2})).createMesh();
    meshes.wall = new Physijs.BoxMesh(threeMesh.geometry, threeMesh.material, 0);
    checkLoad();
});
voxParser.parse('vox/cube2.vox').then(function (voxelData) {
    var threeMesh = (new vox.MeshBuilder(voxelData, {voxelSize: 0.025})).createMesh();
    meshes.cube = new Physijs.BoxMesh(threeMesh.geometry, threeMesh.material, 0);
    checkLoad();
});
voxParser.parse('vox/ground.vox').then(function (voxelData) {
    var threeMesh = (new vox.MeshBuilder(voxelData, {voxelSize: 0.08})).createMesh();
    meshes.ground = new Physijs.BoxMesh(threeMesh.geometry, threeMesh.material, 0);
    checkLoad();
});
voxParser.parse('vox/8x8x8.vox').then(function (voxelData) {
    var threeMesh = (new vox.MeshBuilder(voxelData, {voxelSize: 0.25})).createMesh();
    meshes.x8 = new Physijs.BoxMesh(threeMesh.geometry, threeMesh.material, 0);
    checkLoad();
});
voxParser.parse('vox/chest.vox').then(function (voxelData) {
    var threeMesh = (new vox.MeshBuilder(voxelData, {voxelSize: 0.02})).createMesh();
    meshes.chest = new Physijs.BoxMesh(threeMesh.geometry, threeMesh.material, 0);
    checkLoad();
});
// 场景1初始化方法
function scene1(scene) {
    var loadTree = function (x, y) {
        if (Math.abs(x) > 0.3 || y > 0.3) {
            var mesh = meshes.tree.clone();
            mesh.position.set(x, -0.9, y);
            mesh._physijs.mass = 0;
            var tree = new GameObject(mesh);
            tree.addComponent(new TreeCollider());
            scene.add(tree);
        }
    };
    var loadWall = function (x, y) {
        var mesh = meshes.wall.clone();
        mesh.position.set(x, -2.6, y);
        mesh._physijs.mass = 0;
        scene.add(new GameObject(mesh));
    };
    var loadWall2 = function (x, y) {
        var mesh = meshes.wall.clone();
        mesh.position.set(x, -2.6, y);
        mesh.rotation.set(0, Math.PI / 2, 0);
        mesh._physijs.mass = 0;
        scene.add(new GameObject(mesh));
    };
    var loadCube = function (x, y, z) {
    var mesh = meshes.cube.clone();
    mesh.position.set(x, y, z);
    mesh._physijs.mass = 0;
    scene.add(new GameObject(mesh));
};
    // sky box
    scene.add(THREE.SkyBox(['img/Right.jpg', 'img/Left.jpg', 'img/Up.jpg', 'img/Down.jpg', 'img/Back.jpg', 'img/Front.jpg'], 100));
    // light
    scene.add(new THREE.AmbientLight(0x800000));
    var directionalLight = new THREE.DirectionalLight(0xff5808);
    directionalLight.position.set(0, 0, 1);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    var hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x32CD32, 1);
    hemiLight.position.set(0, -1, -1);
    scene.add(hemiLight);
    // ground
    var mesh = meshes.ground.clone();
    mesh.position.set(0, -1, -1);
    mesh.mass = 0;     // mesh clone 的时候有 bug， 无法 clone _physijs 属性
    mesh.name = "ground";
    scene.add(new GameObject(mesh));
    // 8x8x8
    mesh = meshes.x8.clone();
    mesh.position.set(0, -0.9, -3);
    mesh.rotation.set(0, Math.PI / 2.0, 0);
    mesh.mass = 0;
    scene.add(new GameObject(mesh));
    // chest
    mesh = meshes.chest.clone();
    mesh.position.set(0, -0.9, -4);
    mesh.mass = 0;
    scene.add(new GameObject(mesh));
    // tree
    for (var i = 9; i < 15; i++) {
        for (var j = 9; j < 15; j++) {
            loadTree(i * 0.48 - 5.76 + Math.random() * 0.3 - 0.15, j * 0.48 - 5.76 + Math.random() * 0.3 - 0.15);
        }
    }
    // cube
    for (i = 0; i < 5; i++) {
        loadCube(2.5, -0.8 + 0.4 * i, -0.5 * i);
    }
    // wall
    loadWall(0, 3.2);
    loadWall2(3.2, 0);
    loadWall2(-2, 0);
    // player
    var geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    var material = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true});
    mesh = new Physijs.BoxMesh(geometry, material);
    mesh.position.set(0, -0.5, 1);
    mesh.name = "player";
    var player = new GameObject(mesh);
    var camera = new Camera();
    camera.position.set(0, 0.25, 0);
    player.addComponent(camera);
    var fpc = new FirstPersonController(camera, {sensitivity: 1});
    player.addComponent(fpc);
    player.addComponent(new HUD());
    player.addComponent(new FirstPersonShooter(fpc));
    scene.add(player);
    // dat
    gui.add(fpc, 'sensitivity').min(0).step(0.5);
    gui.add(fpc, 'move_velocity').min(0).step(0.5);
    gui.add(fpc, 'jump_velocity').min(0).step(0.5);

}
document.addEventListener('keydown', Game.requestFullScreen, false);

var loadedCount = 0;
function checkLoad() {
    loadedCount++;
    if (loadedCount === MODEL_COUNT) {
        var scene = new Scene(scene1);
        new Game().setScene(scene).start();
    }
}

/***/ })
/******/ ]);